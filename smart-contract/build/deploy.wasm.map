{"version":3,"sources":["~lib/rt/common.ts","assembly/deploy.ts","~lib/massa-sc-std/index.ts","~lib/rt/stub.ts","~lib/util/error.ts"],"names":[],"mappings":"iRE0bI,AAA6B,AAnVI,KAmVY,GAAgB,EAAuB,EAAuB,EAAqB,EAAqB,IAAS,EAAW,GAAW,KAhXpL,AAAsB,WCWxB,AAAI,EAAO,SAAgC,eArD3C,AAAI,AAsDc,AAAkB,EAAlB,KAtDP,SAA+B,cAlB1C,AAAI,AAsBY,AAFN,AADE,IACO,KAEG,AAVtB,AAAQ,AAAC,KAAmC,GAAY,QAZxC,AADA,AAAC,AAAC,AADA,IACsB,GAAM,GAAW,QAIvD,AAAI,AAAY,AADM,EADJ,AAAO,AAAC,EAAY,GAAY,KAAU,KAAa,aAE1C,KAC7B,AAAI,AAAY,IAAe,SAGnC,AAAS,IAgBT,EAAe,KAmDf,AADa,AAjDb,EAiDsC,UAEtC,OACA,EAAc,KACd,EAAgB,KAChB,AAAO,EAAM,MAqBb","sourceRoot":"./deploy.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","/** ***********************\n * Smart contract that pushes a SC containing a message handler\n * function and sends an asynchronous message to that same SC\n **/\n\n import { send_message, print, create_sc, include_base64 } from \"massa-sc-std\"\n\n export function main(name: string): void {\n     const bytes = include_base64('./build/smart-contract.wasm');\n     const address = create_sc(bytes);\n     send_message(address, \"receive\", 1, 1, 20, 1, 100_000, 1, 100, \"hello my good friend!\");\n     print(\"receiver created and message sent\")\n }","import { JSON } from \"assemblyscript-json\";\n\n@external(\"massa\", \"assembly_script_print\")\nexport declare function assembly_script_print(message: string): void\n@external(\"massa\", \"assembly_script_call\")\nexport declare function assembly_script_call(address: string, func: string, param: string, call_coins: u64): string\n@external(\"massa\", \"assembly_script_get_remaining_gas\")\nexport declare function assembly_script_get_remaining_gas(): u64\n@external(\"massa\", \"assembly_script_create_sc\")\nexport declare function assembly_script_create_sc(bytecode: string): string\n@external(\"massa\", \"assembly_script_set_data\")\nexport declare function assembly_script_set_data(key: string, value: string): void;\n@external(\"massa\", \"assembly_script_set_data_for\")\nexport declare function assembly_script_set_data_for(address: string, key: string, value: string): void;\n@external(\"massa\", \"assembly_script_get_data\")\nexport declare function assembly_script_get_data(key: string): string;\n@external(\"massa\", \"assembly_script_get_data_for\")\nexport declare function assembly_script_get_data_for(address: string, key: string): string;\n@external(\"massa\", \"assembly_script_delete_data\")\nexport declare function assembly_script_delete_data(key: string): void\n@external(\"massa\", \"assembly_script_delete_data_for\")\nexport declare function assembly_script_delete_data_for(address: string, key: string): void\n@external(\"massa\", \"assembly_script_append_data\")\nexport declare function assembly_script_append_data(key: string, value: string): void\n@external(\"massa\", \"assembly_script_append_data_for\")\nexport declare function assembly_script_append_data_for(address: string, key: string, value: string): void\n@external(\"massa\", \"assembly_script_has_data\")\nexport declare function assembly_script_has_data(key: string): bool;\n@external(\"massa\", \"assembly_script_has_data_for\")\nexport declare function assembly_script_has_data_for(address: string, key: string): bool;\n@external(\"massa\", \"assembly_script_get_owned_addresses\")\nexport declare function assembly_script_get_owned_addresses(): string;\n@external(\"massa\", \"assembly_script_get_call_stack\")\nexport declare function assembly_script_get_call_stack(): string;\n@external(\"massa\", \"assembly_script_generate_event\")\nexport declare function assembly_script_generate_event(event: string): void;\n@external(\"massa\", \"assembly_script_transfer_coins\")\nexport declare function assembly_script_transfer_coins(to_address: string, raw_amount: u64): void;\n@external(\"massa\", \"assembly_script_transfer_coins_for\")\nexport declare function assembly_script_transfer_coins_for(from_address: string, to_address: string, raw_amount: u64): void;\n@external(\"massa\", \"assembly_script_get_balance\")\nexport declare function assembly_script_get_balance(): u64;\n@external(\"massa\", \"assembly_script_get_balance_for\")\nexport declare function assembly_script_get_balance_for(address: string): u64;\n@external(\"massa\", \"assembly_script_get_call_coins\")\nexport declare function assembly_script_get_call_coins(): u64;\n@external(\"massa\", \"assembly_script_hash\")\nexport declare function assembly_script_hash(data: string): string;\n@external(\"massa\", \"assembly_script_signature_verify\")\nexport declare function assembly_script_signature_verify(data: string, signature: string, public_key: string): bool;\n@external(\"massa\", \"assembly_script_address_from_public_key\")\nexport declare function assembly_script_address_from_public_key(public_key: string): string;\n@external(\"massa\", \"assembly_script_get_time\")\nexport declare function assembly_script_get_time(): u64;\n@external(\"massa\", \"assembly_script_unsafe_random\")\nexport declare function assembly_script_unsafe_random(): i64;\n@external(\"massa\", \"assembly_script_send_message\")\nexport declare function assembly_script_send_message(target_address: string, target_handler: string, validity_start_period: u64, validity_start_thread: u8, validity_end_period: u64, validity_end_thread: u8, max_gas: u64, gas_price: u64, raw_coins: u64, data: string): void;\n@external(\"massa\", \"assembly_script_get_current_period\")\nexport declare function assembly_script_get_current_period(): u64;\n@external(\"massa\", \"assembly_script_get_current_thread\")\nexport declare function assembly_script_get_current_thread(): u8;\n@external(\"massa\", \"assembly_script_set_bytecode\")\nexport declare function assembly_script_set_bytecode(bytecode: string): void\n@external(\"massa\", \"assembly_script_set_bytecode_for\")\nexport declare function assembly_script_set_bytecode_for(address: string, bytecode: string): void\n\n\n/**\n * Prints in the node logs\n *\n * @param message Message string\n */\nexport function print(message: string): void {\n    assembly_script_print(message);\n}\n\n/**\n * Retreive a module in the ledger at the given address and call a function\n *\n * The function is paramatrized by T the type of the parameters given\n *\n * @param address Address hash in format string\n * @param func Function name exported in the module\n * @param param input parameters as string\n * @param param u64 call coins\n * @returns String output of the function called\n */\nexport function call(address: string, func: string, param: string, call_coins: u64): string {\n    return assembly_script_call(address, func, param, call_coins);\n}\n\n/**\n * Take a base64 string representing the module binary and create an entry in\n * the ledger.\n *\n * The context allow you to write in this smart contract while you're executing\n * the current bytecode.\n *\n * @param bytecode string base64 of the ledger\n * @returns Created entry address\n */\nexport function create_sc(bytecode: string): string {\n    return assembly_script_create_sc(bytecode);\n}\n\nexport namespace Storage {\n    /**\n     * Sets a data entry in the datastore of the current address (top of the call stack).\n     * Existing entries are overwritten and missing ones are created.\n     *\n     * @param key key string\n     * @param value value to set\n     */\n    export function set_data(key: string, value: string): void {\n        assembly_script_set_data(key, value);\n    }\n\n    /**\n     * Sets a data entry in the datastore of a target address (if allowed).\n     * Existing entries are overwritten and missing ones are created.\n     *\n     * @param key key string\n     * @param value value to set\n     */\n    export function set_data_for(address: string, key: string, value: string): void {\n        assembly_script_set_data_for(address, key, value);\n    }\n\n    /**\n     * Returns a data entry from the datastore of the current address (top of the call stack).\n     * Fails if absent.\n     *\n     * @param key key string\n     */\n    export function get_data(key: string): string {\n        return assembly_script_get_data(key);\n    }\n\n    /**\n     * Returns a data entry from the datastore of a target address.\n     * Fails if absent.\n     *\n     * @param key key string\n     */\n    export function get_data_for(address: string, key: string): string {\n        return assembly_script_get_data_for(address, key);\n    }\n\n    /**\n     * Delete an entry from the datastore of the current address (top of the call stack).\n     * Fails if absent.\n     * \n     * @param key key string\n     */\n    export function delete_data(key: string): void {\n        return assembly_script_delete_data(key);\n    }\n\n    /**\n     * Delete an entry from the datastore of a target address.\n     * Fails if absent.\n     * \n     * @param address target address\n     * @param key key string\n     */\n    export function delete_data_for(address: string, key: string): void {\n        return assembly_script_delete_data_for(address, key);\n    }\n\n    /**\n     * Append data to a datastore entry of the current address (top of the call stack).\n     * Fails if absent.\n     * \n     * @param key key string\n     * @param value value to append\n     */\n    export function append_data(key: string, value: string): void {\n        return assembly_script_append_data(key, value);\n    }\n\n    /**\n     * Append data to a datastore entry of a target address.\n     * \n     * @param address target address\n     * @param key key string\n     * @param value value to append\n     */\n    export function append_data_for(address: string, key: string, value: string): void {\n        return assembly_script_append_data_for(address, key, value);\n    }\n\n    /**\n     * Checks whether an entry exists in the caller's datastore.\n     *\n     * @param key key of the data (will be hashed internally)\n     * @returns true if the key was found, false otherwise\n     */\n    export function has_data(key: string): bool {\n        return assembly_script_has_data(key);\n    }\n\n    /**\n     * Checks whether an entry exists in the datastore of an arbitrary address.\n     *\n     * @param address target address\n     * @param key key of the data (will be hashed internally)\n     * @returns true if the key was found, false otherwise\n     */\n    export function has_data_for(address: string, key: string): bool {\n        return assembly_script_has_data_for(address, key);\n    }\n\n    /**\n     *  Returns an entry from the caller's datastore or a default value if not found\n     *\n     * @param address target address\n     * @param key key of the data (will be hashed internally)\n     * @param default_value default value if not found\n     * @returns found string value or default string\n     */\n    export function get_data_or_default(key: string, default_value: string): string {\n        if (has_data(key)) {\n            return get_data(key);\n        }\n        return default_value;\n    }\n\n    /**\n     *  Returns an entry from an address' datastore or a default value if not found\n     *\n     * @param address target address\n     * @param key key of the data (will be hashed internally)\n     * @param default_value default value if not found\n     * @returns found string value or default string\n     */\n     export function get_data_or_default_for(address: string, key: string, default_value: string): string {\n        if (has_data_for(address, key)) {\n            return get_data_for(address, key);\n        }\n        return default_value;\n    }\n\n    /**\n     *  Sets the executable bytecode of an address.\n     *  Fails if the address doesn't exist of if write access rights are missing.\n     *\n     * @param address target address\n     * @param bytecode base64-encoded bytecode\n     */\n    export function set_bytecode_for(address: string, bytecode: string): void {\n        assembly_script_set_bytecode_for(address, bytecode);\n    }\n\n    /**\n     *  Sets the executable bytecode of the current address (top of the call stack).\n     *  Fails if the address doesn't exist of if write access rights are missing.\n     *\n     * @param bytecode base64-encoded bytecode\n     */\n    export function set_bytecode(bytecode: string): void {\n        assembly_script_set_bytecode(bytecode);\n    }\n}\n\nexport namespace Context {\n    /**\n     * Get context current owned addresses.\n     *\n     * You can check your own address or check the addresses of the smart contract you've created during the current execution.\n     *\n     * @returns JSON formated list of addresses containing the owned addresses\n     */\n    export function get_owned_addresses(): string {\n        return assembly_script_get_owned_addresses();\n    }\n\n    /**\n     * Get context current call stack\n     *\n     * The call stack is stack of called module. You can look all previous \\\n     * addresses since the address of the operation sender.\n     *\n     * @returns JSON formated list of addresses containing the call stack\n     */\n    export function get_call_stack(): string[] {\n        return (<JSON.Arr>(JSON.parse(assembly_script_get_call_stack()))).valueOf().map<string>(x => x.toString());\n    }\n\n    /**\n     * Get context current caller address.\n     *\n     * @returns addresse of the caller\n     */\n    export function get_caller(): string {\n        const addresses = get_call_stack();\n        return addresses[addresses.length - 2].toString();\n    }\n\n    /**\n     * Get context current transaction creator address.\n     *\n     * @returns address of the transaction creator\n     */\n    export function get_tx_creator(): string {\n        const addresses = get_call_stack();\n        return addresses[0].toString();\n    }\n\n    /**\n    * Gets the amount of coins transferred in the current call\n    *\n    * @returns Raw amount of coins (in elementary nits)\n    */\n    export function get_call_coins(): u64 {\n        return assembly_script_get_call_coins();\n    }\n\n    /**\n     * Gets the slot unix timestamp in milliseconds\n     *\n     * @returns unix timestamp in milliseconds\n     */\n    export function get_time(): u64 {\n        return assembly_script_get_time();\n    }\n\n    /**\n     * Return the remaining gas available\n     * @returns Gas available\n     */\n    export function get_remaining_gas(): u64 {\n        return assembly_script_get_remaining_gas();\n    }\n}\n\n/**\n * Generates an event\n *\n * @param message String version of the event\n */\nexport function generate_event(event: string): void {\n    assembly_script_generate_event(event);\n}\n\n/**\n * Transfer SCE coins from the current address to to_address\n *\n * @param to_address Destination address hash in format string\n * @param raw_amount Raw amount (in elementary units)\n */\nexport function transfer_coins(to_address: string, raw_amount: u64): void {\n    assembly_script_transfer_coins(to_address, raw_amount);\n}\n\n/**\n * Transfer SCE coins from from_address to to_address\n *\n * @param from_address Source address hash in format string\n * @param to_address Destination address hash in format string\n * @param raw_amount Raw amount (in elementary units)\n */\nexport function transfer_coins_for(from_address: string, to_address: string, raw_amount: u64): void {\n    assembly_script_transfer_coins_for(from_address, to_address, raw_amount);\n}\n\n/**\n * Gets the balance of the current address\n *\n * @returns The raw balance of the address (in elementary nits)\n */\nexport function get_balance(): u64 {\n    return assembly_script_get_balance();\n}\n\n/**\n * Gets the balance of the specified address\n *\n * @param address Address hash in format string\n * @returns The raw balance of the address (in elementary nits)\n */\nexport function get_balance_for(address: string): u64 {\n    return assembly_script_get_balance_for(address);\n}\n\n/**\n * Hash data and return the base58-encoded hash\n *\n * @param data Data to hash\n */\nexport function hash(data: string): string {\n    return assembly_script_hash(data);\n}\n\n/**\n * Hash data and return the base58-encoded hash\n *\n * @param data Data that was signed\n * @param signature base58check signature\n * @param public_key base58check public key\n * @returns true if verification suceeded, false otherwise\n */\nexport function signature_verify(data: string, signature: string, public_key: string): bool {\n    return assembly_script_signature_verify(data, signature, public_key);\n}\n\n/**\n * Converts a public key to an address\n *\n * @param public_key Base58check public key\n * @returns the resulting address\n */\nexport function address_from_public_key(data: string): string {\n    return assembly_script_address_from_public_key(data);\n}\n\n/**\n * Gets an unsafe random i64 (all bits random)\n * This function is unsafe because the random draws can be predicted and manipulated by attackers.\n *\n * @returns random signed 64bit integer\n */\nexport function unsafe_random(): i64 {\n    return assembly_script_unsafe_random();\n}\n\n/**\n * Sends an async message\n *\n * @param target_address Destination address hash in format string\n * @param target_handler Name of the message handling function\n * @param validity_start_period Period of the validity start slot\n * @param validity_start_thread Thread of the validity start slot\n * @param validity_end_period Period of the validity end slot\n * @param validity_end_thread Thread of the validity end slot\n * @param max_gas Maximum gas for the message execution\n * @param gas_price Price of one gas unit\n * @param coins Coins of the sender\n * @param data Message data\n * @returns Nothing\n */\nexport function send_message(target_address: string, target_handler: string, validity_start_period: u64, validity_start_thread: u8, validity_end_period: u64, validity_end_thread: u8, max_gas: u64, gas_price: u64, raw_coins: u64, data: string): void {\n    assembly_script_send_message(target_address, target_handler, validity_start_period, validity_start_thread, validity_end_period, validity_end_thread, max_gas, gas_price, raw_coins, data);\n}\n\n/**\n * Empty function that can be replaced before the compilation with\n * include_base64.js.\n *\n * ```bash\n * node massa_tools/include_base64.js assembly/create_sc.ts && asc assembly/create_sc.m.ts --target release --exportRuntime\n * ```\n * @param _path\n */\nexport function include_base64(_path: string): string {\n    abort('Please use massa tool *include_base64* compilation')\n    return \"/!\\ NOT IMPLEMENTED HERE\";\n}\n\n/**\n * Retrieves the current period\n *\n */\nexport function get_current_period(): u64 {\n    return assembly_script_get_current_period();\n}\n\n/**\n * Retrieves the current thread\n *\n */\nexport function get_current_thread(): u8 {\n    return assembly_script_get_current_thread();\n}\n","import { AL_MASK, OBJECT, OBJECT_OVERHEAD, BLOCK_MAXSIZE, BLOCK_OVERHEAD, BLOCK, OBJECT_MAXSIZE } from \"./common\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === A minimal runtime stub ===\n\n// @ts-ignore: decorator\n@lazy var startOffset: usize = ((__heap_base + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n// @ts-ignore: decorator\n@lazy var offset: usize = startOffset;\n\nfunction maybeGrowMemory(newOffset: usize): void {\n  // assumes newOffset is aligned\n  var pagesBefore = memory.size();\n  var maxOffset = ((<usize>pagesBefore << 16) + AL_MASK) & ~AL_MASK;\n  if (newOffset > maxOffset) {\n    let pagesNeeded = <i32>(((newOffset - maxOffset + 0xffff) & ~0xffff) >>> 16);\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) unreachable(); // out of memory\n    }\n  }\n  offset = newOffset;\n}\n\n// @ts-ignore: decorator\n@inline function computeSize(size: usize): usize {\n  return ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __alloc(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  var block = changetype<BLOCK>(offset);\n  var ptr = offset + BLOCK_OVERHEAD;\n  var payloadSize = computeSize(size);\n  maybeGrowMemory(ptr + payloadSize);\n  block.mmInfo = payloadSize;\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __realloc(ptr: usize, size: usize): usize {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  var actualSize = block.mmInfo;\n  var isLast = ptr + actualSize == offset;\n  var payloadSize = computeSize(size);\n  if (size > actualSize) {\n    if (isLast) { // last block: grow\n      if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n      maybeGrowMemory(ptr + payloadSize);\n      block.mmInfo = payloadSize;\n    } else { // copy to new block at least double the size\n      let newPtr = __alloc(max<usize>(payloadSize, actualSize << 1));\n      memory.copy(newPtr, ptr, actualSize);\n      block = changetype<BLOCK>((ptr = newPtr) - BLOCK_OVERHEAD);\n    }\n  } else if (isLast) { // last block: shrink\n    offset = ptr + payloadSize;\n    block.mmInfo = payloadSize;\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __free(ptr: usize): void {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  if (ptr + block.mmInfo == offset) { // last block: discard\n    offset = changetype<usize>(block);\n  }\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __reset(): void { // special\n  offset = startOffset;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __new(size: usize, id: u32): usize {\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  var ptr = __alloc(OBJECT_OVERHEAD + size);\n  var object = changetype<OBJECT>(ptr - BLOCK_OVERHEAD);\n  object.gcInfo = 0;\n  object.gcInfo2 = 0;\n  object.rtId = id;\n  object.rtSize = <u32>size;\n  return ptr + OBJECT_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __renew(oldPtr: usize, size: usize): usize {\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  var newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size);\n  changetype<OBJECT>(newPtr - BLOCK_OVERHEAD).rtSize = <u32>size;\n  return newPtr + OBJECT_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __visit(ptr: usize, cookie: u32): void { // eslint-disable-line @typescript-eslint/no-unused-vars\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  // nop\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ILLEGALGENTYPE: string = \"Illegal generic type\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n"]}